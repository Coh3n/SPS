(*
SPS ~ SRL Positioning System
============================

Concept and original work done by marpis @ SRL-Forums.

*)

{$loadlib sps}

const
  // Path where all the SPS files are
  SPS_IMG_PATH = IncludePath + 'SPS\img\';
  SPS_IMG_FMT  = '.png';

  // Surfaces
  RUNESCAPE_SURFACE = 0;
  RUNESCAPE_SURFACE_FOLDER = 'runescape_surface\';

  RUNESCAPE_OTHER = 1;
  RUNESCAPE_OTHER_FOLDER = 'runescape_other\';

  // Splits minimap/areas into squares of this side length; used for area recognition
  SPS_SIDE_LENGTH = 5;

// SPS Global variables
var
  SPS_Debug, SPS_MultiMouse: boolean;
  SPS_Areas: TStringArray;
  SPS_AreaMaps: T4DIntegerArray; // Array of grids for each area in SPS_Areas
  SPS_Tolerance, SPS_MinimumMatches: extended;
  SPS_Surface: integer;

// Returns an image of the minimap in a TMufasaBitmap
function SPS_GatherMinimap: TMufasaBitmap;
var
  c: TClient;
begin
  try
    Result := TMufasaBitmap.Create;
    Result.SetSize(150, 150);

    c := getTClient;
    Result.CopyClientToBitmap(
        c.IOManager, false, 0, 0, MMCX-75, MMCY-75, MMCX+75, MMCY+75
      );

  except
    Writeln('[ERROR] in SPS_GatherMinimap: '+ExceptionToString(ExceptionType, ExceptionParam));
  end;
end;

// Gets the starting area coordinates depending on the area image
procedure SPS_GetAreaCoords(Area: string; var x, y: integer);
var
  p: integer;
begin
  // if it's a specific dungeon map (i.e. name isn't 0_0, 10_2, etc.)
  if (length(getNumbers(Area)) < 2) then
  begin
    x := 0;
    y := 0;
    Exit;
  end;

  p := pos('_', Area);

  x := StrToIntDef(copy(Area, 1, p - 1), -1);
  y := StrToIntDef(copy(Area, p + 1, Length(Area) - p), -1);
end;

// Converts a point from a map piece to a point on the entire map
function SPS_LocalToGlobal(Area: string; x, y: integer): TPoint;
var
  cx, cy: integer;
begin
  SPS_GetAreaCoords(Area, cx, cy);
  Result.x := (cx * 400) + x;
  Result.y := (cy * 400) + y;
end;

// Converts a point from the entire map to a point on the main screen
function SPS_GlobalToLocal(x, y: integer): TPoint;
var
  cx, cy: integer;
begin
  cx := Floor(x / 400);
  cy := Floor(y / 400);

  Result.x := x - (cx * 400);
  Result.y := y - (cy * 400);
end;

// Returns the coordinates (x, y) in the form of a string
function SPS_AreaCoordsToString(x, y: integer): string;
begin
  Result := IntToStr(x)+'_'+IntToStr(y);
end;

// Loads the "Area" image
function SPS_GetArea(Area: string; surface: integer): TMufasaBitmap;
var
  x, y: integer;
  S: string;
begin
  SPS_GetAreaCoords(Area, x, y);

  case surface of
    RUNESCAPE_SURFACE: s := RUNESCAPE_SURFACE_FOLDER;
    RUNESCAPE_OTHER: s := RUNESCAPE_OTHER_FOLDER;
  end;

  try
	  Result := TMufasaBitmap.Create;
		Result.LoadFromFile(SPS_IMG_PATH + s + Area + SPS_IMG_FMT);
  except
    Writeln('[SPS] ERROR: SPS_GetArea: '+ExceptionToString(ExceptionType, ExceptionParam));
  end;
end;

// SPS2
function SPS_GetMyPos(): TPoint;
var
  Minimap: TMufasaBitmap;
  SmallMap: T3DIntegerArray;
  t, map, FoundMatches: integer;
  P: TPoint;
begin
  Result := Point(-1, -1);

  if (SPS_Tolerance < 1.0) then
    SPS_Tolerance := 600.0;

  if (SPS_MinimumMatches = 0.0) then
    SPS_MinimumMatches := 0.35;

  if not LoggedIn then
    Exit;

  if (inRange(round(rs_GetCompassAngleDegrees), 10, 350)) then
    MakeCompass('N');

  t := getSystemTime;

  Minimap := SPS_GatherMinimap;
  SPS_FilterMinimap(Minimap);
  //DrawBitmapDebugImg(Minimap.Index);
  //DisplayDebugImgWindow(150, 150);
  SmallMap := [];
  SmallMap := SPS_BitmapToMap(Minimap, SPS_SIDE_LENGTH);

  map := SPS_FindMapInMap(P.x, P.y, SPS_AreaMaps, SmallMap, SPS_Tolerance, FoundMatches);
{
  writeln('fx: '+toStr(p.x)+' ~ on area: '+toStr(p.x * SPS_SIDE_LENGTH));
  writeln('fy: '+toStr(p.y)+' ~ on area: '+toStr(p.y * SPS_SIDE_LENGTH));
  writeln('matches: '+toStr(foundMatches));
  writeln('area index: '+toStr(map));
}
  if ((FoundMatches / 706.0) > SPS_MinimumMatches) then
    // the "* SPS_SIDE_LENGTH" is because P.X and P.Y are the coords of the grid piece the map was found in
    Result := SPS_LocalToGlobal(SPS_Areas[map],
                P.X * SPS_SIDE_LENGTH, P.Y * SPS_SIDE_LENGTH);

  Minimap.Free;

  t := (GetSystemTime - t);
  if (SPS_Debug) then
    Writeln('[SPS] SPS_GetMyPos() Finished in '+ToStr(t)+' ms. Result = '+ToStr(Result));
end;

// Finds position P in minimap by checking your own location
function SPS_PosToMM(P: TPoint): TPoint;
var
  MyPos: TPoint;
begin
  if not LoggedIn then
    Exit;

  Result := Point(-1, -1);
  MyPos := SPS_GetMyPos;

  if (Distance(MyPos.X, MyPos.Y, P.X, P.Y) < 75) then
    Result := Point(MMCX + P.X - MyPos.X, MMCY + P.Y - MyPos.Y);
end;

// Walks to position, P.
function SPS_WalkToPos(P: TPoint): boolean;
var
  MM: TPoint;
begin
  if not LoggedIn then
    Exit;

  MM := SPS_PosToMM(P);

  if (MM.X > 0) then
  begin
    if (SPS_MultiMouse) then
      MultiMouse(MM.X, MM.Y, 25, 3, false)
    else
      Mouse(MM.X, MM.Y, 0, 0, mouse_Left);

    if WaitFunc(@IsMoving, 1, 3000 + random(500)) then
      while IsMoving do
        Flag;

    Result := True;
  end;
end;

// Returns true if the point "Pt" is on the minimap
function SPS_PosOnMM(Pt: TPoint): Boolean;
var
  p: TPoint;
begin
  p := SPS_PosToMM(Pt);
  Result := rs_OnMinimap(p.x, p.y);
end;

// Walks the path "Path"; always walks to the furthest point possible
function SPS_WalkPath(Path: TPointArray): boolean;
var
  I, H, T, D: integer;
  P, MM: TPoint;
begin
  H := High(Path);
  T := GetSystemTime + 20000 + Random(5000);

  while (not Result) and (GetSystemTime < T) do
  begin
    RunEnergy(20);

    P := SPS_GetMyPos;
    for I := H downto 0 do
    begin
      MM.X := MMCX + Path[I].X - P.X;
      MM.Y := MMCY + Path[I].Y - P.Y;

      D := Distance(MM.X, MM.Y, MMCX, MMCY);

      if (D < 10) then
        break
      else
        if (D < 70) then
        begin
          if (SPS_MultiMouse) then
            MultiMouse(MM.X, MM.Y, 25, 3, false)
          else
            Mouse(MM.X, MM.Y, 0, 0, mouse_Left);

          FFlag(Integer(I <> H) * 15);

          T := getSystemTime + 20000 + Random(1000);
 	        Break;
        end;
    end;

    Result := (I = H);
  end;
end;

// Generates a TPA from point(xs, ys) to point(xe, ye)
function SPS_WindPath(xs, ys, xe, ye, gravity, wind, maxStep, targetArea: extended): TPointArray;
var
  veloX, veloY, windX, windY, veloMag, dist, randomDist, lastDist, step: extended;
  lastX, lastY: integer;
  sqrt2, sqrt3, sqrt5: extended;
begin
  sqrt2:= sqrt(2);
  sqrt3:= sqrt(3);
  sqrt5:= sqrt(5);

  while (hypot(xs - xe, ys - ye) > 1) do
  begin
    dist := hypot(xs - xe, ys - ye);
    wind := minE(wind, dist);

    if (dist >= targetArea) then
    begin
      windX := (windX / sqrt3 + (random(round(wind) * 2 + 5) - wind) / sqrt5);
      windY := (windY / sqrt3 + (random(round(wind) * 2 + 5) - wind) / sqrt5);
    end else begin
      windX := (windX / sqrt2);
      windY := (windY / sqrt2);

      if (maxStep < 15) then
        maxStep := (random(15) + 15)
      else
        maxStep := (maxStep / sqrt5);
    end;

    veloX := (veloX + windX);
    veloY := (veloY + windY);
    veloX := (veloX + gravity * (xe - xs) / dist);
    veloY := (veloY + gravity * (ye - ys) / dist);

    if (hypot(veloX, veloY) > maxStep) then
    begin
      randomDist := (maxStep / 2.0 + random(round(maxStep) / 2));
      veloMag := sqrt(veloX * veloX + veloY * veloY);
      veloX := ((veloX / veloMag) * randomDist);
      veloY := ((veloY / veloMag) * randomDist);
    end;

    lastX := round(xs);
    lastY := round(ys);
    xs := (xs + veloX);
    ys := (ys + veloY);

    setLength(result, length(result) + 1);
    result[high(result)] := point(round(xs), round(ys));

    step := hypot(xs - lastX, ys - lastY);
    lastdist := dist;
  end;
end;

// Walks from the player's current position to the point T
function SPS_WindWalk(T: TPoint): Boolean;
var
  I, Tries: Integer;
  M, P: TPoint;
  ctrlPoints: TPointArray;
begin
  P := T;

  repeat
    M := SPS_GetMyPos;

    if (Length(ctrlPoints) = 0) then
      ctrlPoints := SPS_WindPath(M.X, M.Y, P.X, P.Y, 22.5, 12.5, 40, 10);

    Inc(Tries);
    if (Tries > 20) then
      Exit;

    Result := SPS_WalkPath(ctrlPoints);
  until(Result);
end;

// Sets up SPS; needs to be called if you want to switch RS surfaces
procedure SPS_Setup(surface: integer; areas: TStringArray);
var
  l, i, t: integer;
  tmp: TMufasaBitmap;
begin
  t := getSystemTime;
  l := Length(areas);
  SetLength(SPS_AreaMaps, l);
  SetLength(SPS_Areas, l);
  SPS_Surface := surface;
  SPS_MultiMouse := true;

  for i := 0 to (l - 1) do
  begin
    tmp := SPS_GetArea(areas[i], surface);
    SPS_AreaMaps[i] := SPS_BitmapToMap(tmp, SPS_SIDE_LENGTH);
    SPS_Areas[i] := areas[i];
    tmp.free;
  end;

  t := (getSystemTime - t);

  if (SPS_Debug) then
    writeln('[SPS] SPS_Setup() took '+toStr(t)+' ms. Loaded '+toStr(L)+' areas.');
end;

